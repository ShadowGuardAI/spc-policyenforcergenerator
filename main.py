import argparse
import yaml
import json
import logging
import jsonschema
from jsonschema import validate
import os
import sys

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def setup_argparse():
    """
    Sets up the argument parser for the script.

    Returns:
        argparse.ArgumentParser: The argument parser object.
    """
    parser = argparse.ArgumentParser(description='Generate enforcement scripts from policy documents.')
    parser.add_argument('policy_file', help='Path to the policy file (YAML or JSON).')
    parser.add_argument('--output_file', '-o', default='enforcement_script.sh', help='Path to the output enforcement script.')
    parser.add_argument('--script_type', '-s', choices=['bash', 'python'], default='bash', help='Type of script to generate.')
    parser.add_argument('--log_level', '-l', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], default='INFO', help='Set the logging level.')
    parser.add_argument('--validate_schema', '-v', help='Path to JSON schema file for policy validation.')
    return parser

def load_policy(policy_file):
    """
    Loads the policy document from a YAML or JSON file.

    Args:
        policy_file (str): Path to the policy file.

    Returns:
        dict: The policy document as a dictionary.  Returns None on error.
    """
    try:
        with open(policy_file, 'r') as f:
            if policy_file.endswith('.yaml') or policy_file.endswith('.yml'):
                return yaml.safe_load(f)
            elif policy_file.endswith('.json'):
                return json.load(f)
            else:
                logging.error("Unsupported file format.  Use YAML or JSON.")
                return None
    except FileNotFoundError:
        logging.error(f"Policy file not found: {policy_file}")
        return None
    except yaml.YAMLError as e:
        logging.error(f"Error parsing YAML file: {e}")
        return None
    except json.JSONDecodeError as e:
        logging.error(f"Error parsing JSON file: {e}")
        return None
    except Exception as e:
        logging.error(f"An unexpected error occurred loading the policy file: {e}")
        return None


def validate_policy(policy, schema_file):
    """
    Validates the policy document against a JSON schema.

    Args:
        policy (dict): The policy document.
        schema_file (str): Path to the JSON schema file.

    Returns:
        bool: True if the policy is valid, False otherwise.
    """
    try:
        with open(schema_file, 'r') as f:
            schema = json.load(f)
        validate(instance=policy, schema=schema)
        logging.info("Policy document validated successfully against the schema.")
        return True
    except FileNotFoundError:
        logging.error(f"Schema file not found: {schema_file}")
        return False
    except json.JSONDecodeError as e:
        logging.error(f"Error parsing JSON schema file: {e}")
        return False
    except jsonschema.exceptions.ValidationError as e:
        logging.error(f"Policy document validation failed: {e}")
        logging.error(e)  # Log the specific validation error.
        return False
    except Exception as e:
        logging.error(f"An unexpected error occurred validating the policy: {e}")
        return False

def generate_enforcement_script(policy, script_type):
    """
    Generates an enforcement script based on the policy document.

    Args:
        policy (dict): The policy document.
        script_type (str): The type of script to generate (bash or python).

    Returns:
        str: The generated enforcement script.
    """
    script = ""
    if script_type == 'bash':
        script += "#!/bin/bash\n"
        script += "# Generated by spc-PolicyEnforcerGenerator\n\n"
        for rule_name, rule_details in policy.items():
            if 'description' in rule_details:
                script += f"# {rule_details['description']}\n"
            if 'check' in rule_details:
                script += f"# Checking: {rule_name}\n"
                script += f"{rule_details['check']}\n"
            if 'enforce' in rule_details:
                 script += f"# Enforcing: {rule_name}\n"
                 script += f"{rule_details['enforce']}\n"
            script += "\n"
    elif script_type == 'python':
        script += "#!/usr/bin/env python3\n"
        script += "# Generated by spc-PolicyEnforcerGenerator\n\n"
        script += "import os\n"
        script += "import subprocess\n\n"

        def execute_command(command):
           """Executes a shell command and returns the output and error."""
           try:
                result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
                return result.stdout, result.stderr
           except subprocess.CalledProcessError as e:
                return e.stdout, e.stderr


        script += "def execute_command(command):\n"
        script += "    try:\n"
        script += "        result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)\n"
        script += "        return result.stdout, result.stderr\n"
        script += "    except subprocess.CalledProcessError as e:\n"
        script += "        return e.stdout, e.stderr\n\n"


        for rule_name, rule_details in policy.items():
            if 'description' in rule_details:
                script += f"# {rule_details['description']}\n"
            if 'check' in rule_details:
                script += f"# Checking: {rule_name}\n"
                script += f"print(f'Checking {rule_name}')\n"
                script += f"output, error = execute_command('{rule_details['check']}')\n"
                script += f"if error:\n"
                script += f"   print(f'Error checking {rule_name}: {{error}}')\n"
                script += f"else:\n"
                script += f"   print(f'Check output: {{output}}')\n"

            if 'enforce' in rule_details:
                script += f"# Enforcing: {rule_name}\n"
                script += f"print(f'Enforcing {rule_name}')\n"
                script += f"output, error = execute_command('{rule_details['enforce']}')\n"
                script += f"if error:\n"
                script += f"   print(f'Error enforcing {rule_name}: {{error}}')\n"
                script += f"else:\n"
                script += f"   print(f'Enforcement output: {{output}}')\n"

            script += "\n"
    else:
        logging.error(f"Unsupported script type: {script_type}")
        return None

    return script

def write_script_to_file(script, output_file, script_type):
    """
    Writes the generated script to a file.

    Args:
        script (str): The generated script.
        output_file (str): Path to the output file.
        script_type (str):  Type of script to create (for setting executable permissions).

    Returns:
        bool: True if the script was written successfully, False otherwise.
    """
    try:
        with open(output_file, 'w') as f:
            f.write(script)
        if script_type == 'bash':
            os.chmod(output_file, 0o755) # Make bash script executable
        elif script_type == 'python':
            pass  # No need to chmod python scripts - they are executed by interpreter
        logging.info(f"Enforcement script written to: {output_file}")
        return True
    except Exception as e:
        logging.error(f"Error writing script to file: {e}")
        return False


def main():
    """
    Main function of the script.
    """
    parser = setup_argparse()
    args = parser.parse_args()

    # Set log level
    logging.getLogger().setLevel(args.log_level)

    # Load the policy document
    policy = load_policy(args.policy_file)
    if policy is None:
        sys.exit(1)  # Exit if policy loading fails

    # Validate the policy against schema, if provided
    if args.validate_schema:
        if not validate_policy(policy, args.validate_schema):
            sys.exit(1) # Exit if validation fails

    # Generate the enforcement script
    script = generate_enforcement_script(policy, args.script_type)
    if script is None:
        sys.exit(1)

    # Write the script to a file
    if not write_script_to_file(script, args.output_file, args.script_type):
        sys.exit(1)


if __name__ == "__main__":
    main()